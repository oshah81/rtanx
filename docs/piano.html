<!doctype html>
<html>
<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Player Piano</title>
	<link rel="shortcut icon" type="image/x-icon" href="favicon.png" />
	<link rel="preload" href="piano.json" as="fetch" crossorigin="anonymous" />
<style type="text/css">


	.keyboard {
		width: 50vw;
		min-height: 300px;
		transform: scale(1.5);
		transform-origin: 0% 0%;
		user-select: none;
	}
	button {
		border: none;
	}
	button:focus {
		outline: none;
	}

	.white-notes .mapped-to {
		color: #888888;
		font-size: 0.5rem;
	}

	.white-notes button {
		height: 150px;
		width: 30px;
		position: absolute;
		z-index: 1;
		border: 1px solid #404040;
		background-color: ivory;
		display: inline-grid;
		place-content: end center;
	}

	.white-notes button:hover {
		background-color: #ddd5e8;
	}

	.white-notes button[data-pressed="yes"] {
		background-color: #ddd5e8;
	}

	.black-notes button {
		position: absolute;
		height: 90px;
		width: 20px;
		z-index: 2;
		background-color: #404040;
		font-size: 0px;
		display: inline-grid;
		place-content: end center;
		padding-bottom: 0.25rem;
	}

	.black-notes button[data-pressed="yes"] {
		background-color: #808080;
		border: 1px solid ivory;
	}

	.black-notes button:hover {
		background-color: #808080;
		border: 1px solid ivory;
	}

	.black-notes .mapped-to {
		color: #888888;
		font-size: 0.5rem;
	}

	.container {
		display: grid;
		grid-template-areas: "aside" "main" "footer";
		place-items: center;
	}

	.container > aside { grid-area: aside; }
	.container > main { grid-area: main; }
	.container > footer { grid-area: footer; }

	#splash {
		z-index: 1;
		background-color: rgba(255, 255, 255, 0.8);
		width: 100vw;
		height: 98vh;
		position: absolute;
		top: 0;
		left: 0;
		text-align: center;
		font-size: 80vh;
	}

</style>
</head>
<body>
	<div class="container">
		<aside class="settingsBar">
			<label>Volume:
				<input type="range" min="0.0" max="1.0" step="0.01" value="0.5" list="volumesDrop" name="volume" />
			</label>
			<datalist id="volumesDrop">
				<option value="0.0" label="Mute">
				<option value="1.0" label="100%">
			</datalist>
			<label>Game Type:
			<select id="gameType" oninput="window.newGame(event)">
				<option>Free</option>
				<option>Timed</option>
				<option>Stepped</option>
			</select>
			</label>
		</aside>
		<main>
			<section class="keyboard">
				<div class="black-notes">
				</div>
				<div class="white-notes">
				</div>
			</section>
		</main>
		<footer>
			<span id="steppedGame" hidden="hidden">Press enter to move to next round</span>
		</footer>
	</div>
	<div id="splash" hidden="hidden">6</div>

	<script type="module">

		window.eventLog = [];


		const keyboard = document.querySelector(".keyboard");
		const oscList = [];
		const audioContext = new AudioContext();
		let keymap = null;
		let defaultOctave = null;
		let notes = "";
		let currentNote = 0;
		let roundTime = 4000;
		let noTimedGame = true;

		window.newGame = async function (evt) {
			evt.target.blur();
			eventLog = [];
			currentNote = 0;
			noTimedGame = true;

			if (evt.target.value === "Stepped") {
				document.getElementById("steppedGame").hidden = false;
				document.getElementById("splash").hidden = true;
			} else if (evt.target.value === "Timed") {
				document.getElementById("steppedGame").hidden = true;
				document.getElementById("splash").hidden = false;
				noTimedGame = false;
				await startTimedGame();
			} else {
				document.getElementById("steppedGame").hidden = true;
				document.getElementById("splash").hidden = true;
			}
		}

		window.playNextRound = async function() {
			const nextSequence = [...notes.slice(currentNote, currentNote + 4)];
			currentNote = (currentNote + 4) % notes.length;

			playSequence(nextSequence);
			eventLog.push({ type: "startNextRound", gameType: "stepped", time: performance.now(), sequence: nextSequence });
		}

		window.setup = function setup(gameconfig) {
			const whiteKeyboard = document.querySelector(".keyboard .white-notes");
			const blackKeyboard = document.querySelector(".keyboard .black-notes");
			keymap = gameconfig.keymap;
			defaultOctave = gameconfig.defaultOctave;
			notes = gameconfig.notes;
			roundTime = gameconfig.roundTime;

			for (let item of gameconfig.keyboard) {
				const matchedKey = keymap.find(x => x.note === item.note && ((x.octave === undefined || x.octave === null) && item.octave === defaultOctave || x.octave === item.octave));
				if (!matchedKey) {
					continue;
				}
				const musicKey = document.createElement("button");
				musicKey.dataset.note = item.note;
				musicKey.dataset.octave = item.octave;
				musicKey.dataset.freq = item.freq;
				musicKey.dataset.key = matchedKey.key;
				musicKey.style.left = `${item.alignment}px`;
				musicKey.textContent = item.note;
				const keyLabel = document.createElement("span");
				keyLabel.className = "mapped-to";
				keyLabel.textContent = matchedKey.key;
				musicKey.appendChild(keyLabel);

				hookEvents(musicKey);

				if (item.note.length > 1) {
					musicKey.className = "key black-key";
					blackKeyboard.appendChild(musicKey);
				} else {
					musicKey.className = "key white-key";
					whiteKeyboard.appendChild(musicKey);
				}
			}

			hookKeymap();
		}

		async function startTimedGame() {
			if (noTimedGame) {
				return;
			}
			const timingElem = document.getElementById("splash");
			let timing = 6;
			timingElem.textContent = timing;
			timingElem.hidden = false;
			while (--timing > 0) {
				timingElem.textContent = timing;
				await wait(1000);
			}
			timingElem.hidden = true;
			const nextSequence = [...notes.slice(currentNote, currentNote + 4)];
			currentNote = (currentNote + 4) % notes.length;
			await playSequence(nextSequence);
			eventLog.push({ type: "startNextRound", gameType: "timed", time: performance.now(), sequence: nextSequence });
			await wait (roundTime);
			startTimedGame();
		}

		function hookKeymap() {
			document.addEventListener("keydown", event => keyNotePressed(event));
			document.addEventListener("keyup", event => keyNoteUnPressed(event));
		}

		async function keyNotePressed(evt) {
			if (evt.repeat) {
				return;
			}
			if (!document.getElementById("splash").hidden) {
				return;
			}
			if (evt.key === " " || evt.key === "Return" || evt.key === "Enter") {
				if (document.getElementById("gameType").value === "Stepped") {
					await playNextRound();
				}
				return;
			}
			const matchedKey = keymap.find(x => x.key === evt.key);
			if (matchedKey) {
				const volumeControl = document.querySelector("input[name='volume']");
				const octave = (matchedKey.octave !== undefined) ? matchedKey.octave : defaultOctave;
				const note = matchedKey.note;
				eventLog.push({ type: "keydown", time: performance.now(), key: evt.key });

				const matchedElem = document.querySelector(`.keyboard .key[data-note="${note}"][data-octave="${octave}"]`);
				oscList[octave + note] = playTone(matchedElem.dataset.freq, volumeControl.value);
				matchedElem.dataset.pressed = "yes";
			}
		}

		function keyNoteUnPressed(evt) {
			const matchedKey = keymap.find(x => x.key === evt.key);
			if (matchedKey) {
				const octave = (matchedKey.octave !== undefined) ? matchedKey.octave : defaultOctave;
				const note = matchedKey.note;
				const matchedElem = document.querySelector(`.keyboard .key[data-note="${note}"][data-octave="${octave}"]`);
				if (matchedElem) {
					const dataset = matchedElem.dataset;
					matchedElem.dataset.pressed = "";
					eventLog.push({ type: "keyup", time: performance.now(), key: evt.key });

					/*
					if (dataset && dataset.pressed === "yes") {
						oscList[dataset.octave+dataset.note].stop();
						oscList[dataset.octave+dataset.note] = null;
						dataset.pressed = "";
					}
					*/
				}
			}
		}

		function hookEvents(keyElement) {
			keyElement.addEventListener("mousedown", notePressed, false);
			keyElement.addEventListener("mouseup", noteReleased, false);
			keyElement.addEventListener("mouseover", notePressed, false);
			keyElement.addEventListener("mouseleave", noteReleased, false);
		}


		async function playSequence(sequence) {
			if (sequence.length == 0) {
				return;
			}
			const item = sequence.pop();
			const volumeControl = document.querySelector("input[name='volume']");

			const matchedKey = keymap.find(x => x.key === item);
			const octave = (matchedKey.octave !== undefined) ? matchedKey.octave : defaultOctave;
			const note = matchedKey.note;

			const matchedElem = document.querySelector(`.keyboard .key[data-note="${note}"][data-octave="${octave}"]`);
			oscList[octave + note] = playTone(matchedElem.dataset.freq, volumeControl.value);
			matchedElem.dataset.pressed = "yes";

			await wait (500);
			matchedElem.dataset.pressed = "";
			await playSequence(sequence);
		}

		async function wait(ms) {
			return new Promise(resolve => {
				setTimeout(resolve, ms);
			});
		}

		function playTone(freq, volume, finish) {

			const osc = audioContext.createOscillator();
			// osc.connect(masterGainNode);
			const decayRate = 1.5; // seconds
			const envelope = audioContext.createGain();

			osc.frequency.value = parseFloat(freq);
			osc.type = "triangle";
			envelope.gain.value = volume;

			osc.connect(envelope);
			envelope.connect(audioContext.destination);

			// osc.start();

			osc.start(audioContext.currentTime)

			envelope.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + decayRate)
			setTimeout(() => {
				osc.stop(audioContext.currentTime);
				if (finish) {
					finish();
				}
			}, decayRate * 1000)

			return osc;
		}

		function notePressed(event) {
			if (event.buttons & 1) {
				const dataset = event.target.dataset;
				const volumeControl = document.querySelector("input[name='volume']");
				eventLog.push({ type: "keydown", time: performance.now(), key: dataset.key });

				if (!document.getElementById("splash").hidden) {
					return;
				}

				if (!dataset.pressed) {
					oscList[dataset.octave+dataset.note] = playTone(dataset.freq, volumeControl.value);
					dataset.pressed = "yes";
				}
			}

		}

		function noteReleased(event) {
			const dataset = event.target.dataset;
			if (event.type !== "mouseleave") {
				eventLog.push({ type: "keyup", time: performance.now(), key: dataset.key });
			}

			if (dataset.pressed === "yes") {
				dataset.pressed = "";
			}
		}
	</script>

	<script type="module">
		const getConfig = async function() {
			const response = await fetch("piano.json", {
				type: "GET",
				credentials: "same-origin"
			});
			const gameConfig = await response.json();
			window.setup(gameConfig);
		}

		getConfig();
	</script>
</body>
</html>
